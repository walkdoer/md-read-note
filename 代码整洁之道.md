代码整洁之道
=====================

## 1. 整洁代码

#### 什么样的代码算是整洁？
- 只做好一件事情
- 没有重复代码
- 代码逻辑直接了当，只包含必须的代码
- 尽可能少的依赖关系，便于维护
- 明确的定义，提供清晰的尽可能少的API
- 小块的代码块
- 好的表达力（体现在变量名，方法和类的抽象等）
- 完善错误处理代码（容易被忽略的细节）
- 一致性（架构设计，变量名，编码规范等）


> 让营地比你来的时候更加干净

这一条童子军军规，恰如其分的表达了我的愿望，让项目的代码质量随之时间的推移变得越来越好

## 2. 有意义的命名

#### 避免误导

例如: 不要用accountList来指定一组账号，除非它真的是List类型，可以使用accounts或者accountGroup

#### 有意义的区分

例如: 

1. 使用Product ProductInfo ProductData来表示3个不同类的话是很难区分的，因为Info和Data意义上并没有太大的区别，容易混淆，类似的还有moneyCount和money
2. nameString真的比name更加清晰吗？

- 类名和对象应该是名词，或者名词短语，不应该是动词
- 方法名应该是动词，或者动词短语


## 3. 函数

- 短小
- 只做一件事（函数中的代码处于同一个抽象层级）
- 无副作用 只做一件事可以保证无副作用，但是一个无副作用的函数不一定就只做一件事。所以这里不能将无副作用看成是上一点“只做一件事”的结果。副作用：时序性的耦合，顺序依赖。
- 给函数起一个好名字（包括一致的命名方式）
	* 动词+关键字（名词）`writeFile`要优于模糊不清的`write`
- 尽可能少的函数参数（当然,0个是最优的）
	* 合理的二元函数 例如笛卡尔点 new Point(10, 10) 这个是自然的秩序，二元是必然的
	* 参数较多，就该考虑是否需要抽象为对象 ```drawCircle(double x, double y, double radius)``` 可以改写为 ```drawCircle(Point p, double radius)```.将多元函数成功降元。
- 标志参数

	```
	render(boolean isMobile);
	```
	可以改写为两个函数:

	```
	renderForMobile()  和 renderForPC()
	``` 
- 输出参出  `appendFooter` 在不查看函数声明的时候, 直觉的会把参数当做输入参数，也就是`appendFooter(footer)` 但是如果函数声明为`void appendFooter(StringBuffer report)`,就会恍然大悟了原来是输出参数。优化的方法，可以改写为： `report.appendFooter(footer)` 
- 错误处理
	- 抽离try/catch代码块
	- 使用异常的优势
		+ 将异常处理代码从主路径中分离出来(P42-3.9)
- Don't Repeat Yourself (DRY)

> 语言是程序员设计用来描述系统的。函数是语言的动词，类是语言的名词。大师级程序员把系统当做故事来讲，而不是当做程序来写。他们使用编程语言提供的工具来搭建一种更为丰富，更有表达力的语言，用来讲那个故事。
使用清晰精确的语言来讲述一个故事。

## 4. 注释

#### 注释是一种失败

无法用代码语言清晰直接表达自己的思路，而需要简洁用其他语言来表达自己的意图。这个时候最好考虑一下是否先改造代码，而不是添加注释。

#### 注释会撒谎

程序员很难坚持维护注释，导致注释和代码随之时间的推移会慢慢脱节，所以尽可能用代码语言来解释，因为代码是唯一正确的信息源。

#### 值得写的注释

- 法律信息
- 对意图的解释
- 警示
- TODO
- Public API DOC（私有函数是否需要API文档值得商榷）

#### 应该删除的注释

要写就必须写好注释，不要喃喃自语的废话

- 多余的注释
- 被注释掉的无用代码（这也属于注释的一部分）

#### 需要改进的注释

- 解释的不够详细
- 可以用代码语言便可解释清楚的注释就不要用注释

## 5. 单元测试

测试代码和生产代码一样重要，测试代码的可读性甚至要跟强。不好的测试相当于没有测试，因为迟早会因为难以维护而起不到单元测试的作用。

#### 单元测试的编写步骤

1. **Build** 构造测试数据
2. **Operate** 操作测试数据
3. **Check** 检查测试数据

## 6. 类

#### 封装
隐藏实现并非只是在变量之间放上一个函数层那么简单，隐藏实现关乎抽象。下意识的使用Getter和Setter将变量推向外部（public）,这样的行为是不可取的。每一个公有接口都应该是深思熟虑过的，一遍用户无需了解数据的实现细节就能够操作数据的本体

#### 类应该短小
可以用代码行数(LOC)来衡量函数的大小，用什么来衡量一个类的大小呢？ **权责！**

- **单一权责**
- **内聚**

	将类中的大函数分割成几个小函数，但是这样子，小函数之间就会通过函数参数进行通信，而将函数参数上升为类的属性变量，就不需要传参数了，但是这样子也意味着类丧失了内聚性，因为出现了越来越多避免传参数而出现的类变量。为了提高这些类的内聚，就会拆分这些类。所以将大函数拆解为小函数，往往也是将类拆分为多个小类的契机。
- 类的方法应该细粒度（甚至是原子操作）


